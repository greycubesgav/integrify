#!/usr/bin/env bash

# Default action
# 1 = Check if checksum stored and correct, report
# 2 = Add new checksum

digest='sha1'
quiet=0 # 1 = only show mismatched files
verbose=0
debug=1

function show_help {
 cat << EOF
Usage: ${0##*/} [OPTIONS] FILE
Check the integ checksum file attribute and optionally add the checksum

Option  Meaning

 -c     Check the checksum
 -a     Add a new checksum to FILE
 -d     Remove the checksum from FILE
 -l     List files checksums as per a sfv file
 -f     Set the digest function to write, default 'sha1'
 -v     Verbose messages


Examples:
   Check a files integrity checksum
     ${0##*/} myfile.jpg

   Add a new checksum to a file
     ${0##*/} -w myfile.jpg

Info:
  When copying files, extended attributes should be preserved to ensure
  integrity data is copied.
  e.g. rsync -X source destination
       osx : cp -p source destination

  This script assumes opensll is available in your path.
EOF
  exit 1
}

function generate_checksum {
  digest="$1"
  input_file="$2"
  calc_cs=$(openssl dgst -${digest} "${input_file}" | awk '{print $2}')
  echo "${calc_cs}"
}

function read_checksum {
  input_file="$1"
  selected=0
  if [[ "${OSTYPE}" =~ ^linux* ]]; then
    selected=1
    stored_cs=$(getfattr -n "${attrib_key}" "${input_file}" 2>/dev/null  | grep "${attrib_key}" | awk -F'=' '{print $2}' | sed -e 's/\"//g' )
  elif [[ "${OSTYPE}" =~ ^darwin* ]]; then
    selected=1
    stored_cs_raw=$(xattr -p "${attrib_key}" "${input_file}" 2>/dev/null )
    stored_cs="${stored_cs_raw}"
  elif [[ "${OSTYPE}" =~ ^freebsd* ]]; then
    selected=1
    stored_cs=$(getextattr user "${attrib_key}" "${input_file}" 2>/dev/null | awk '{print $2}' )
  fi
  if [ "$selected" -eq '0' ]; then
    echo "Did not find a suitable OS type for ${OSTYPE}" 1>&2
  fi
  echo "${stored_cs}"
}

function write_checksum {
  checksum="$1"
  input_file="$2"
  selected=0
  if [[ "${OSTYPE}" =~ ^linux* ]]; then
    selected=1
    stored_cs_raw=$(setfattr -n "${attrib_key}" -v "${checksum}" "${input_file}")
    ret=$?
  elif [[ "${OSTYPE}" =~ ^darwin* ]]; then
    selected=1
    result=$(xattr -w "${attrib_key}" "${checksum}" "${input_file}" 1>&2)
    ret=$?
  elif [[ "${OSTYPE}" =~ ^freebsd* ]]; then
    selected=1
    setextattr user "${attrib_key}" "${checksum}" "${input_file}" #2>/dev/null
    ret=$?
  fi
  if [ "$selected" -eq '0' ]; then
    echo "Did not find a suitable OS type for ${OSTYPE}" 1>&2
  fi
  return $?
}

function remove_checksum {
  input_file="$1"
  selected=0
  if [[ "${OSTYPE}" =~ ^linux* ]]; then
    selected=1
    setfattr -x "${attrib_key}" "${input_file}" 2>/dev/null
    ret=$?
  elif [[ "${OSTYPE}" =~ ^darwin* ]]; then
    selected=1
    xattr -d "${attrib_key}" "${input_file}" 2>/dev/null
    ret=$?
  elif [[ "${OSTYPE}" =~ ^freebsd* ]]; then
    selected=1
    rmextattr user "${attrib_key}" "${checksum}" "${input_file}" 2>/dev/null
    ret=$?
  fi
  if [ "$selected" -eq '0' ]; then
    echo "Did not find a suitable OS type for ${OSTYPE}" 1>&2
  fi
  return $?
}

# Set Default Options
verbose=0
digest='sha1'
action='check'

OPTIND=1
while getopts "vh?ardlcf:" opt; do
    case "$opt" in
    h|\?)
        show_help
        exit 0
        ;;
    a)  action='write'
        ;;
    d)  action='delete'
        ;;
    l)  action='list'
        ;;
    c)  action='check'
        ;;
    v)  verbose='1'
        ;;
    f)  digest="${OPTARG}"
        ;;
    esac
done

shift "$((OPTIND-1))" # Shift off the options and optional --.

# Set the attribute
attrib_key="integ.${digest}"
if [[ "${OSTYPE}" == 'linux-gnu' ]]; then
  attrib_key="user.${attrib_key}"
fi

if [ -z "$1" ]; then
  show_help
  exit 0
fi

for filename in "$@"
do

if [ ! -e "${filename}" ]; then
  echo "${filename} File not found!" 1>&2
  continue
fi

if [ "${action}" == 'list' ]; then
   file_current_checksum=$(read_checksum "${filename}")
   echo "${filename} ${file_current_checksum}"
fi
# Generate the checksum for the file, we always need this

if [ "${action}" == 'write' ]; then
  #--------------------------------------
  # Add new checksum
  #--------------------------------------
  # This code assumes that it is not worth;
  #   reading any existing checksum,
  #   calculating the current checksum
  #   comparing
  #   only writing a new one if it's difference
  # If the read access of a device is *significantly* faster than a write, it
  # may be more efficient to read any current checksum first to save a potential
  # write. This code does not assume this.
  # Algorithm:
  #  Calculate the current checksum
  #  Write it to the file attribute
  #  Read the checksum from disk and compare to in memory calculated one, this
  #   ensures the attribute was written to disk ok

  # Calculate the current checksum
  file_calc_checksum=$(generate_checksum "${digest}" "${filename}")

  # Write the checksum to disk
  write_checksum "${file_calc_checksum}" "${filename}"
  ret=$?
  if [ "$ret" -eq "0" ]; then
    file_current_checksum=$(read_checksum "${filename}")
    if [ "${file_calc_checksum}" == "${file_current_checksum}" ]; then
      echo -n "${filename}"
      if [ "$verbose" -gt "0" ]; then
        echo -n ": ${digest} : ${file_calc_checksum}"
      fi
      echo " : added"
    else
      echo "Calculated checksum and filesystem read checksum differ!" 1>&2
      echo "${filename} : disk; ${file_current_checksum} : calc; ${file_calc_checksum}" 1>&2
      exit 4
    fi
  else
    echo "Error writing checksum to attribute" 1>&2
    exit 2
  fi
fi

if [ "$action" == 'delete' ]; then
 remove_checksum "${filename}"
 file_current_checksum=$(read_checksum "${filename}")
 if [ "${file_current_checksum}" == "" ]; then
   # We don't have any checksum
   echo -n "${filename} "
   if [ "$verbose" -gt "0" ]; then
     echo -n ": ${digest} "
   fi
   echo ": <removed>"
 else
   echo "Failed to remove checksum for digest ${digest}" 1>&2
 fi
fi

if [ "$action" == 'check' ]; then
  # Check if checksum stored and correct, report
  # Get any current checksum
  file_current_checksum=$(read_checksum "${filename}")
  if [ "${file_current_checksum}" == "" ]; then
    # We don't have any checksum
    echo "${filename} : <none>"
  else
    file_calc_checksum=$(generate_checksum "${digest}" "${filename}")
    if [ "${file_calc_checksum}" == "${file_current_checksum}" ]; then
      echo -n "${filename}"
      if [ "$verbose" -gt "0" ]; then
        echo -n " : ${digest} : ${file_calc_checksum}"
      fi
      echo " : passed"
    else
      if [ "$verbose" -gt "0" ]; then
        echo "${filename} : ${digest} : disk; ${file_current_checksum} : calc; ${file_calc_checksum}" 1>&2
      else
        echo "${filename} : fail" 1>&2
      fi
      exit 4
    fi
  fi
fi

done
